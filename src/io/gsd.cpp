// Copyright Â© 2020 Conor Williams <conorwilliams@outlook.com>

// SPDX-License-Identifier: GPL-3.0-or-later

// This file is part of openFLY.

// OpenFLY is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

// OpenFLY is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along with openFLY. If not, see <https://www.gnu.org/licenses/>.

#include "libfly/io/gsd.hpp"

#include <fmt/core.h>

#include <cstdint>
#include <cstring>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string_view>
#include <type_traits>
#include <utility>

#include "external/gsd.h"
#include "libfly/utility/asserts.hpp"
#include "libfly/utility/core.hpp"

namespace fly::io {

  template <typename F, typename... Args>
  void throw_err(std::string_view fname, F&& f, Args&&... args) {
    switch (std::invoke(std::forward<F>(f), std::forward<Args>(args)...)) {
      case GSD_SUCCESS:
        return;
      case GSD_ERROR_IO:
        throw std::runtime_error(fmt::format("GSD: {} - {}", std::strerror(errno), fname));
      case GSD_ERROR_INVALID_ARGUMENT:
        throw std::runtime_error(fmt::format("GSD: Invalid argument - {}", fname));
      case GSD_ERROR_NOT_A_GSD_FILE:
        throw std::runtime_error(fmt::format("GSD: Not a GSD file - {}", fname));
      case GSD_ERROR_INVALID_GSD_FILE_VERSION:
        throw std::runtime_error(fmt::format("GSD: Invalid GSD file version - {}", fname));
      case GSD_ERROR_FILE_CORRUPT:
        throw std::runtime_error(fmt::format("GSD: File corrupt - {}", fname));
      case GSD_ERROR_MEMORY_ALLOCATION_FAILED:
        throw std::runtime_error(fmt::format("GSD: Memory allocation failed - {}", fname));
      case GSD_ERROR_NAMELIST_FULL:
        throw std::runtime_error(fmt::format("GSD: Namelist full - {}", fname));
      case GSD_ERROR_FILE_MUST_BE_WRITABLE:
        throw std::runtime_error(fmt::format("GSD: File must be writeable - {}", fname));
      case GSD_ERROR_FILE_MUST_BE_READABLE:
        throw std::runtime_error(fmt::format("GSD: File must be readable - {}", fname));
      default:
        throw std::runtime_error(fmt::format("GSD: Unknown error - {}", fname));
    }
  }

  gsd_index_entry const* find_chunk(struct gsd_handle* handle, int frame, const char* name) {
    if (gsd_index_entry const* chunk = gsd_find_chunk(handle, safe_cast<uint64_t>(frame), name)) {
      return chunk;
    } else {
      throw std::runtime_error(fmt::format("GSD: Could not find chunk with name: '{}'", name));
    }
  }

  gsd_index_entry const* check_chunk(gsd_index_entry const* chunk, uint64_t N, uint32_t M, uint8_t type) {
    if (chunk->N != N && chunk->M != M && chunk->type != type) {
      throw std::runtime_error("Chunk has unexpected shape/type");
    } else {
      return chunk;
    }
  }

  FileGSD::FileGSD(std::string_view fname, Flags flag) : m_fname(fname), m_handle(std::make_unique<gsd_handle>()) {
    //
    if (spatial_dims != 3) {
      throw std::runtime_error("GSD files are currently only supported in 3D");
    }
    //
    constexpr char const* app = "openFLY";

    auto version = gsd_make_version(1, 4);

    switch (flag) {
      case read:
        throw_err(m_fname, gsd_open, m_handle.get(), m_fname.c_str(), GSD_OPEN_READONLY);
        break;
      case read_write:
        throw_err(m_fname, gsd_open, m_handle.get(), m_fname.c_str(), GSD_OPEN_READWRITE);
        break;
      case create:
        throw_err(m_fname, gsd_create_and_open, m_handle.get(), m_fname.c_str(), app, "hoomd", version, GSD_OPEN_READWRITE, 0);
        break;
    }

    if (std::strcmp(m_handle->header.application, app) != 0) {
      throw std::runtime_error("Opening a file generated by a different application");
    }
  }

  void FileGSD::clear() { throw_err(m_fname, gsd_truncate, m_handle.get()); }

  int FileGSD::n_frames() const noexcept { return safe_cast<int>(gsd_get_nframes(m_handle.get())); }

  FileGSD::~FileGSD() noexcept { throw_err(m_fname, gsd_close, m_handle.get()); }

  void FileGSD::dump_impl(system::Box const& box) {
    //
    // Dump the configuration

    //          |L_x    xy L_y   xz L_z|
    // basis =  |0         L_y   yz L_z|
    //          |0         0        L_z|

    Mat<double> basis = box.basis();

    double hoomd_basis[6];  // L_x, L_y, L_z , xy, xz, yz

    hoomd_basis[0] = basis(0, 0);
    hoomd_basis[1] = basis(1, 1);
    hoomd_basis[2] = basis(2, 2);

    hoomd_basis[3] = basis(0, 1);
    hoomd_basis[4] = basis(0, 2);
    hoomd_basis[5] = basis(1, 2);

    throw_err(m_fname, gsd_write_chunk, m_handle.get(), "configuration/box", GSD_TYPE_DOUBLE, 6, 1, 0, hoomd_basis);

    // Dump the periodicity

    std::uint8_t pr[3] = {box.periodic(0), box.periodic(1), box.periodic(2)};

    throw_err(m_fname, gsd_write_chunk, m_handle.get(), "log/periodicity", GSD_TYPE_UINT8, 3, 1, 0, pr);
  }

  void FileGSD::load_impl(int i, system::Box& box) const {
    //

    Mat<double> basis = Mat<double>::Zero();

    {  // Load the configuration

      double hoomd_basis[6]{};  // L_x, L_y, L_z , xy, xz, yz

      gsd_index_entry const* chunk = find_chunk(m_handle.get(), i, "configuration/box");
      check_chunk(chunk, 6, 1, GSD_TYPE_DOUBLE);
      throw_err(m_fname, gsd_read_chunk, m_handle.get(), hoomd_basis, chunk);

      basis(0, 0) = hoomd_basis[0];
      basis(1, 1) = hoomd_basis[1];
      basis(2, 2) = hoomd_basis[2];

      basis(0, 1) = hoomd_basis[3];
      basis(0, 2) = hoomd_basis[4];
      basis(1, 2) = hoomd_basis[5];
    }
    // Load the periodicity

    Arr<bool> periodicity = Arr<bool>::Zero();

    {
      std::uint8_t pr[3]{};  // = {box.periodic(0), box.periodic(1), box.periodic(2)};

      gsd_index_entry const* chunk = find_chunk(m_handle.get(), i, "log/periodicity");
      check_chunk(chunk, 3, 1, GSD_TYPE_UINT8);
      throw_err(m_fname, gsd_read_chunk, m_handle.get(), pr, chunk);

      periodicity[0] = pr[0];
      periodicity[1] = pr[1];
      periodicity[2] = pr[2];
    }

    box = system::Box(basis, periodicity);
  }

  void FileGSD::commit_frame() { throw_err(m_fname, gsd_end_frame, m_handle.get()); }

}  // namespace fly::io